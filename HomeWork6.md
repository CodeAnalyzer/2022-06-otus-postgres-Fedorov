Создать учебную ВМ, установить Postgres 14

![Альт-текст](https://i.ibb.co/2nxgszt/Home-Work6-1.png)

![Альт-текст](https://i.ibb.co/bvkLJTh/Home-Work6-2.png)

`Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках,
удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале
появятся такие сообщения.`

Нужно включить параметр log_lock_waits.
В этом случае в журнал сообщений сервера будет попадать информация, если транзакция ждала дольше, чем deadlock_timeout.

![Альт-текст](https://i.ibb.co/C71nkVv/Home-Work6-3.png)
![Альт-текст](https://i.ibb.co/4j7J4Mz/Home-Work6-4.png)
![Альт-текст](https://i.ibb.co/QJWs83n/Home-Work6-5.png)

Воспроизведение

Первый процесс
* create table test (id integer primary key, value text);
* insert into test (id, value) select 1, 'ODIN';
* begin;
* select pg_backend_pid();
* update test set value = 'DVA' where id=1;
* -->> переходим ко второму процессу
* SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 17857;
* commit;

Второй процесс
* begin;
* select pg_backend_pid();
* update test set value = 'TRY' where id=1; <<< Висит на блокировке, ждет коммита первого процесса
* commit;

![Альт-текст](https://i.ibb.co/cN6HZ24/Home-Work6-6.png)
https://i.ibb.co/cN6HZ24/Home-Work6-6.png

Содержимое лога 

sudo nano /var/log/postgresql/postgresql-14-main.log

![Альт-текст](https://i.ibb.co/LZ67YNq/Home-Work6-7.png)
https://i.ibb.co/LZ67YNq/Home-Work6-7.png

`Смоделируйте ситуацию обновления одной и той же строки командами UPDATE в разных сеансах.
Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны.
Пришлите список блокировок и объясните, что значит каждая.`

![Альт-текст](https://i.ibb.co/thqtSJH/Home-Work6-8.png)
https://i.ibb.co/thqtSJH/Home-Work6-8.png

ACCESS SHARE - самый слабый режим блокировки, совместим с любыми кроме ACCESS EXCLUSIVE, выставляется при выполнении SELECT. Блокировка выставлена на представление (вьюхи) pg_locks, потому что в транзакции выполнили SELECT из него.

ROW EXCLUSIVE - блокировку в этом режиме получает любая команда, которая изменяет данные в таблице. Конфликтует с режимами блокировки SHARE, SHARE ROW EXCLUSIVE, EXCLUSIVE и ACCESS EXCLUSIVE. Блокировка выставлена на таблицу test и первичный ключ этой таблицы, потому что в транзакции изменяли ее.

EXCLUSIVE - режим совместим только с блокировкой ACCESS SHARE, то есть параллельно с транзакцией, получившей блокировку в этом режиме, допускается только чтение таблицы. Конфликтует с режимами блокировки ROW SHARE, ROW EXCLUSIVE, SHARE UPDATE EXCLUSIVE, SHARE, SHARE ROW EXCLUSIVE, EXCLUSIVE и ACCESS EXCLUSIVE.
- Выставляется на ИД виртуальной транзакции virtualxid, потому что запрашивая pg_locks, мы фактически выполняем запрос и, следовательно, начинаем транзакцию. Однако, PostgreSQL не хочет выделять реальные идентификаторы транзакций, прежде чем они действительно понадобятся. Поэтому виртуальный ИД.
- Выставляется на ИД транзакции явно начатой командой BEGIN.

`Воспроизведите взаимоблокировку транзакций.
Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?`

Воспроизведение

Первый процесс
* insert into test (id, value) select 2, 'DVA';
* begin;
* select pg_backend_pid();
* update test set value = 'AAA' where id=1;
* -->> переходим ко второму процессу
* update test set value = 'BBB' where id=2;
* commit;

Второй процесс
* begin;
* select pg_backend_pid();
* update test set value = 'AAA' where id=2;
* -->> переходим ко первому процессу
* update test set value = 'BBB' where id=1;
* commit;


![Альт-текст](https://i.ibb.co/Sn7tBGs/Home-Work6-9.png)
https://i.ibb.co/Sn7tBGs/Home-Work6-9.png

sudo nano /var/log/postgresql/postgresql-14-main.log

![Альт-текст](https://i.ibb.co/DGCNX7D/Home-Work6-10.png)
https://i.ibb.co/DGCNX7D/Home-Work6-10.png

Классический дидлок.

Процесс 18057 в транзакции 753 изменил запись с ИД=1, заблокировал ее и хочет изменить запись с ИД=2.
Процесс 18052 в транзакции 754 изменил запись с ИД=2, заблокировал ее и хочет изменить запись с ИД=1.
Каждый из процессов висит на блокировке порожденной другим процессом.
Жертвой выбран 18052.

См. https://temofeev.ru/info/articles/blokirovki-v-postgresql-3-blokirovki-drugikh-obektov/

Проверка на взамоблокировку требует определенных усилий, которые не хочется прилагать всякий раз, когда запрашивается новая блокировка (все-таки взаимоблокировки достаточно редки). Поэтому когда процесс пытается захватить блокировку и не может, он встает в очередь и засыпает, но взводит таймер на значение, указанное в параметре deadlock_timeout (по умолчанию — 1 секунда). Если ресурс освобождается раньше, то и хорошо, мы сэкономили на проверке. А вот если по истечении deadlock_timeout ожидание продолжается, тогда ожидающий процесс будет разбужен и инициирует проверку.

Если проверка (которая состоит в построении графа ожиданий и поиска в нем контуров) не выявила взаимоблокировок, то процесс продолжает спать — теперь уже до победного конца. Если же взаимоблокировка выявлена, то одна из транзакций (в большинстве случаев — та, которая инициировала проверку) принудительно обрывается. При этом освобождаются захваченные ей блокировки и остальные транзакции могут продолжать работу.

`Могут ли две транзакции, выполняющие единственную команду UPDATE
одной и той же таблицы (без where), заблокировать друг друга?`

см. https://habr.com/ru/company/postgrespro/blog/465263/

Команда UPDATE блокирует строки по мере их обновления. Это происходит не одномоментно.
Поэтому если одна команда будет обновлять строки в одном порядке, а другая — в обратно, они могут взаимозаблокироваться.

