Создать Учебную ВМ

![Альт-текст](https://i.ibb.co/2jv62Q9/Home-Work5-1.png)

Установить на него PostgreSQL 14 с дефолтными настройками

Применить параметры настройки PostgreSQL (postgresql.conf) из прикрепленного к материалам занятия файла

* **_max_connections = 40_** -- максимальное число конкурентных подключений к серверу PostgreSQL
* **_shared_buffers = 1GB_** -- сколько выделенной памяти будет использоваться PostgreSQL для кеширования
* **_effective_cache_size = 3GB_** -- сообщает оптимизатору объем кеша, доступный в ядре
* **_maintenance_work_mem = 512MB_** -- задаёт максимальный объём памяти для операций обслуживания БД
* **_checkpoint_completion_target = 0.9_** -- задаёт целевое время для завершения процедуры контрольной точки, как коэффициент для общего времени между контрольными точками
* **_wal_buffers = 16MB_** -- объём разделяемой памяти, который будет использоваться для буферизации данных WAL, ещё не записанных на диск
* **_default_statistics_target = 500_** -- объём информации, сохраняемой в pg_statistic командой ANALYZE, по умолчанию 100 записей
* **_random_page_cost = 4_** -- задаёт приблизительную стоимость чтения одной произвольной страницы с диска
* **_effective_io_concurrency = 2_** -- задаёт допустимое число параллельных операций ввода/вывода, которое говорит PostgreSQL о том, сколько операций ввода/вывода могут быть выполнены одновременно.
* **_work_mem = 6553kB_** -- задаёт базовый максимальный объём памяти, который будет использоваться во внутренних операциях при обработке запросов, прежде чем будут задействованы временные файлы на диске.
* **_min_wal_size = 4GB_** -- пока WAL занимает на диске меньше этого объёма, старые файлы WAL в контрольных точках всегда перерабатываются, а не удаляются
* **_max_wal_size = 16GB_** -- Максимальный размер, до которого может вырастать WAL во время автоматических контрольных точек

Описание параметров - https://postgrespro.ru/docs/postgresql/14/bookindex

![Альт-текст](https://i.ibb.co/fFRt4By/Home-Work5-2.png)

Выполнить **_pgbench -i postgres_**

* -I (или --initialize) Требуется для вызова режима инициализации
* Ошибка - pgbench: error: connection to server on socket "/var/run/postgresql/.s.PGSQL.5432" failed: FATAL:  role "otus" does not exist
* Вот так заработал **_sudo -u postgres pgbench -i postgres_**

Описание pgbench - https://postgrespro.ru/docs/postgresql/14/pgbench

![Альт-текст](https://i.ibb.co/1zRPvFZ/Home-Work5-3.png)

Запустить **_pgbench -c8 -P 60 -T 3600 -U postgres postgres_**

Вот так сработало **_sudo -u postgres pgbench --client=8 --progress=60 --time=3600 --username=postgres postgres_**

* **_client=8_** -- число имитируемых клиентов, то есть число одновременных сеансов базы данных
* **_progress=60_** -- выводить отчёт о прогрессе через заданное число секунд
* **_time=3600_** -- выполнять тест с ограничением по времени (в секундах)
* **_username=postgres_** -- имя пользователя для подключения

Дать отработать до конца

![Альт-текст](https://i.ibb.co/NTMrsVP/Home-Work5-4.png)

Зафиксировать среднее значение tps в последней ⅙ части работы

* Среднее tps за последние 10мин = **_656,4_**

А дальше настроить autovacuum максимально эффективно

* **_sudo nano /etc/postgresql/14/main/postgresql.conf_**
* **_sudo -u postgres pgbench -i postgres_**
* **_sudo -u postgres pgbench --client=8 --progress=60 --time=3600 --username=postgres postgres_**
* "Держи VACUUM в голоде. Настройка AutoVacuum в PostgreSQL" - https://infostart.ru/1c/articles/1191667/
* Automatic Vacuuming - https://www.postgresql.org/docs/current/runtime-config-autovacuum.html

![Альт-текст](https://i.ibb.co/jGFmqnr/Home-Work5-5.png)

Так, чтобы получить максимально ровное значение tps на горизонте часа

![Альт-текст](https://i.ibb.co/2k1bkNz/Home-Work5-6.png)

Согласно рекомендациям (ссылка выше) нужно устанавливать количество ворекров равным примерно половине от количества ядер.
Созданная ВМ имеет два ядра, т.е. нужно уменьшить количество ворекров с дефолтного значения 3 до 1-2.
Но на 1 результат оказался хуже, поэтому оставил 2.
При этом сохранил дефолтное значение autovacuum_vacuum_cost_limit, его изменение только ухудшало значение.
Значение autovacuum_vacuum_cost_delay с дефолтного 2ms поднял до 5ms чтобы они не так агрессивно чистили базу, больше времени оставляя на обслуживание клиентских потоков.

В результате TPS подрос, среднеквадратичное отклонение уменьшилось (разброс меньше), ну и дельта между мин. и макс. значениями тоже уменьшилась. 